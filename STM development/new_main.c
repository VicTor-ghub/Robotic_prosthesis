/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include "stm32f0xx.h"
#include "main.h"
#include "bsp.h"
#include "delay.h"
#include <stdlib.h>
#include <stdio.h>

// Static functions

static void SystemClock_Config(void);

// Global variables

uint16_t in, input; // old, very_old, command;
uint16_t pulse;

uint32_t xn_futur, xn, xn_passe,TKE;

uint16_t adc_dma_buffer[3];

// Main program

int main()
{
	// Local variables
	uint16_t c1, c2;
	uint32_t x1, x2, y1, y2 = 0;

//	uint16_t c3, c4, c5;    // Filter coefs
//	uint32_t x1, x2, x3, x4 = 0;    // Filter variable
//	uint32_t out_ext, old_ext, old_out_ext, out_flex, old_flex, old_out_flex = 0;
//	uint32_t tmp_flex, tmp_ext = 0;

	// Setup filter coefs
	c1 = 482;
	c2 = 3614;

//	// Setup filter coefs low pass
//	c1 = 0.3913;		// x[n]
//	c2 = 0.7827;		// x[n-1]
//	c3 = 0.3913;		// x[n-2]
//	// Retour
//	c4 = 0.3695;		// y[n-1]
//	c5 = 0.1958;		// y[n-2]

//	// Setup filter coefs low pass
//	c1 = 0.4208;		// x[n]
//	c2 = 0;				// x[n-1]
//	c3 = -0.4208;		// x[n-2]
//	// Retour
//	c4 = -0.4425;		// y[n-1]
//	c5 = 0.1584;		// y[n-2]

	// Initialize variables
//	old = 50;
//	very_old = 150;

	// Initialize PWM middle
	pulse = 1500;

	// Configure System Clock
	SystemClock_Config();

	// Initialize LED pin
	BSP_LED_Init();

	// Turn LED On
	BSP_LED_On();

	// Turn LED Off
	BSP_LED_Off();

	// Initialize and start time base
	BSP_TIMER_Timebase_Init();

	// Initialize Debug Console
	BSP_Console_Init();
	my_printf("Console ready!\r\n");

	// Initialize and start ADC on PC1 and PC2
	BSP_ADC_Init();
	my_printf("ADC ready!\r\n");

	// Initialize Timer for delays
	BSP_DELAY_TIM_init();

	// Initialize Timer for PWM output
	BSP_TIMER_PWM_Init();

	BSP_NVIC_Init();

	// Main loop
	while(1)
	{
		// Start measure

		// Hand command
		TIM1->CCR2 = pulse;

		// Input signal <-- ADC
		while ((ADC1->ISR & ADC_ISR_EOC) != ADC_ISR_EOC);
		in = adc_dma_buffer[0]; 							// channel 11_Flexor
		input = adc_dma_buffer[1]; 							// channel 12_Extensor

		// DEBUG
		//my_printf("Flexor value = %d\r\n", in);
		//my_printf("Extensor value = %d\r\n", input);

		// Low filter stage
		x1 = in;
		y1 = (c1*x1) + (c2*y1);
		y1 = (y1 >>12U);		// Remove decimal part
		in = y1;

		// Low filter stage
		x2 = input;
		y2 = (c1*x2) + (c2*y2);
		y2 = (y2 >>12U);		// Remove decimal part
		input = y2;

//		// Band filter stage
//		old_flex= x2;
//		x2 = x1;
//		x1 = in;
//		old_out_flex = tmp_flex;
//		tmp_flex = out_flex;
//		out_flex = (c1*x1) + (c2*x2) +(c3*old_flex) + (c4*tmp_flex) + (c5*old_out_flex);
//		in = out_flex;
//
//		// Band filter stage
//		old_ext = x4;
//		x4 = x3;
//		x3 = input;
//		old_out_ext = tmp_ext;
//		tmp_ext = out_ext;
//		out_ext = (c1*x1) + (c2*x2) +(c3*old_ext) + (c4*tmp_ext) + (c5*old_out_ext);
//		input = out_ext;

		// DEBUG
		my_printf("Flexor filtered = %d\r\n", in);
		my_printf("Extensor filtered = %d\r\n", input);

		// Teager-Kaiser filter (activity detection)
//		xn_futur = in;
//		xn = old;
//		xn_passe = very_old;
//
//		TKE = xn*xn - xn_passe*xn_futur;
//		command = TKE;

		// DEBUG
		//my_printf("ADC value = %d\r\n", command);

		// Treshold
		if (input >= 1000)
		{
			if (pulse > 500 )					// Open hand
			{
				BSP_LED_On();
				pulse = 500;
			}
			else
			BSP_LED_Off();
		}
		else if (in >= 1000)
		{
			if (pulse < 2500 )					// Close hand
			{
				BSP_LED_On();
				pulse = 2500;
			}
			else
			BSP_LED_Off();
		}

		// Manage state machine			( TEST COMMANDE MAIN )
//				switch (state)
//				{
//					// Increasing A, Decreasing B
//					case 0 :
//					{
//						pulse+= 6;
//
//
//						// Stop condition -> State 1
//						if (pulse >= 2500) state = 1;
//						break;
//					}
//
//					// Increasing B, Decreasing A
//					case 1 :
//					{
//						pulse -= 6;
//
//
//						// Stop condition -> State 0
//						if (pulse <= 1000) state = 0;
//						break;
//					}
//				}

		// Save old data
		// very_old = old;
		// old = in;

		// Stop measure

		// Wait for 100ms
		 BSP_DELAY_TIM_ms(100);

		// Wait for 1s test
		//BSP_DELAY_TIM_ms(1);
	}
}

/*
 * 	Clock configuration for the Nucleo STM32F072RB board
 * 	HSE input Bypass Mode 			-> 8MHz
 * 	SYSCLK, AHB, APB1 				-> 48MHz
*  	PA8 as MCO with /16 prescaler 		-> 3MHz
 *
 *  Vico
 */

static void SystemClock_Config()
{
	uint32_t	HSE_Status;
	uint32_t	PLL_Status;
	uint32_t	SW_Status;
	uint32_t	timeout = 0;

	timeout = 1000000;

	// Start HSE in Bypass Mode
	RCC->CR |= RCC_CR_HSEBYP;
	RCC->CR |= RCC_CR_HSEON;

	// Wait until HSE is ready
	do
	{
		HSE_Status = RCC->CR & RCC_CR_HSERDY_Msk;
		timeout--;
	} while ((HSE_Status == 0) && (timeout > 0));

	// Select HSE as PLL input source
	RCC->CFGR &= ~RCC_CFGR_PLLSRC_Msk;
	RCC->CFGR |= (0x02 <<RCC_CFGR_PLLSRC_Pos);

	// Set PLL PREDIV to /1
	RCC->CFGR2 = 0x00000000;

	// Set PLL MUL to x6
	RCC->CFGR &= ~RCC_CFGR_PLLMUL_Msk;
	RCC->CFGR |= (0x04 <<RCC_CFGR_PLLMUL_Pos);

	// Enable the main PLL
	RCC-> CR |= RCC_CR_PLLON;

	// Wait until PLL is ready
	do
	{
		PLL_Status = RCC->CR & RCC_CR_PLLRDY_Msk;
		timeout--;
	} while ((PLL_Status == 0) && (timeout > 0));

        // Set AHB prescaler to /1
	RCC->CFGR &= ~RCC_CFGR_HPRE_Msk;
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

	//Set APB1 prescaler to /1
	RCC->CFGR &= ~RCC_CFGR_PPRE_Msk;
	RCC->CFGR |= RCC_CFGR_PPRE_DIV1;

	// Enable FLASH Prefetch Buffer and set Flash Latency
	FLASH->ACR = FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY;

	/* --- Until this point, MCU was still clocked by HSI at 8MHz ---*/
	/* --- Switching to PLL at 48MHz Now!  Fasten your seat belt! ---*/

	// Select the main PLL as system clock source
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_PLL;

	// Wait until PLL becomes main switch input
	do
	{
		SW_Status = (RCC->CFGR & RCC_CFGR_SWS_Msk);
		timeout--;
	} while ((SW_Status != RCC_CFGR_SWS_PLL) && (timeout > 0));

	/* --- Here we go! ---*/

	/*--- Use PA8 as MCO output at 48/16 = 3MHz ---*/

	// Set MCO source as SYSCLK (48MHz)
	RCC->CFGR &= ~RCC_CFGR_MCO_Msk;
	RCC->CFGR |=  RCC_CFGR_MCOSEL_SYSCLK;

	// Set MCO prescaler to /16 -> 3MHz
	RCC->CFGR &= ~RCC_CFGR_MCOPRE_Msk;
	RCC->CFGR |=  RCC_CFGR_MCOPRE_DIV16;

	// Enable GPIOA clock
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;

	// Configure PA8 as Alternate function
	GPIOA->MODER &= ~GPIO_MODER_MODER8_Msk;
	GPIOA->MODER |= (0x02 <<GPIO_MODER_MODER8_Pos);

	// Set to AF0 (MCO output)
	GPIOA->AFR[1] &= ~(0x0000000F);
	GPIOA->AFR[1] |=  (0x00000000);

	// Update SystemCoreClock global variable
	SystemCoreClockUpdate();
}
